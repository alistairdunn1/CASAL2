#' @title extract.mcmc function for casal2 output
#'
#' @description
#' An extract function that reads objective and sample output that are produced from a 'casal2 -m' model run. This function
#' also creates a 'casal2.mcmc' class which can be used in plotting and summary functions.
#'
#' @author C. Marsh & A. Dunn
#' @param samples.file <string> the name of the input file containing the samples.file output by Casal2
#' @param objectives.file <string> the name of the input file containing the objectives.file output by Casal2 (optional - set objectives.file = "" to ignore the objectives file).
#' @param path Optional<string>, the path to the file
#' @param return_covariance Optional<bool>, Whether you want to extract the covariance matrix with the mcmc object?
#' @param fileEncoding Optional, allows the R-library to read in files that have been encoded in alternative UTF formats, see the manual for the error message that would indicate when to use this switch.
#' @param quiet suppress information messages.
#' @export
#' @return a 'casal2MCMC' that can be integrated using the str() function.
#'
"extract.mcmc" <- function(samples.file = "samples.1", objectives.file = "objectives.1", path = "", return_covariance = FALSE, fileEncoding = "", quiet = FALSE) {
  set.class <- function(object, new.class) {
    # use in the form
    #  object <- set.class(object,"new class")
    attributes(object)$class <- c(new.class, attributes(object)$class[attributes(object)$class != new.class])
    object
  }
  if (missing(path)) {
    path <- ""
  }

  sample_filename <- make.filename(path = path, file = samples.file)
  sample_file <- convert.to.lines(sample_filename, fileEncoding = fileEncoding, quiet = quiet)
  samples_temp <- get.lines(sample_file, starts.with = "\\*", fixed = F)
  is.samples <- FALSE
  if (substr(samples_temp, 1, 13) != "*mcmc_sample[") {
    stop(paste0("expected the header of ", samples.file, " to read *mcmc_sample[_label_], please check this is mcmc output generated by Casal2"))
  }
  #########################
  ## Deal with the samples.mcmc.1 <- extract.mcmc("samples.1", "", path = PATH, quiet = TRUE)
  #########################
  if (length(sample_file) < 3) {
    stop(paste0("No parameter values found in samples file ", samples.file))
  }
  header <- string.to.vector.of.words(sample_file[2])

  ## check that the last row has the same number of columns as the first column. Sometimes MCMC quit early and the report is interrupted
  first_params <- string.to.vector.of.words(sample_file[3])
  last_params <- string.to.vector.of.words(sample_file[length(sample_file)])
  if (length(first_params) != length(last_params)) {
    ## remove the last row
    sample_file <- sample_file[-length(sample_file)]
  }
  ## create a data.frame
  samples_dataframe <- read.table(textConnection(sample_file[3:length(sample_file)]))
  colnames(samples_dataframe) <- header

  #########################
  ## Deal with the Objectives
  #########################
  if (!(is.null(objectives.file) || objectives.file == "")) {
    objective_filename <- make.filename(path = path, file = objectives.file)
    objective_file <- convert.to.lines(objective_filename, fileEncoding = fileEncoding, quiet = quiet)
    ## build covariance matrix
    covariance_lines <- get.lines(objective_file, clip.to.match = "starting_covariance_matrix", clip.from.match = "samples", fixed = F)
    columns <- string.to.vector.of.words(covariance_lines[1])
    covariance_matrix <- matrix(0, length(columns), length(columns))
    if ((length(covariance_lines) - 1) != length(columns)) {
      stop(paste0("The number of rows of data (", length(covariance_lines) - 1, ") for the covariance matrix is not the same as the number of elements in the header (", length(columns), ")"))
    }
    for (i in 2:length(covariance_lines)) {
      line <- string.to.vector.of.numbers(covariance_lines[i])
      if (length(line) != length(columns)) {
        stop(paste0("The number of elements for the covariance matrix on line ", i, " (", length(line), ") is not the same number of elements in the header (", length(columns), ")"))
      }
      covariance_matrix[i - 1, ] <- line
    }
    dimnames(covariance_matrix) <- list(columns, columns)

    ## now pull out the objectives table
    objective_lines <- get.lines(objective_file, clip.to.match = "samples", fixed = F)
    objective_dataframe <- read.table(textConnection(objective_lines[2:length(objective_lines)]))
    objective_header <- string.to.vector.of.words(objective_lines[1])
    colnames(objective_dataframe) <- as.character(objective_header)

    if (nrow(objective_dataframe) != nrow(samples_dataframe)) {
      stop(paste0(
        "There were a different number of data rows in the objectives file (",
        nrow(objective_dataframe), ") than the samples file (", nrow(samples_dataframe),
        "). These should be the same. Please check the files ", objectives.file, " and ",
        samples.file
      ))
    } else if (!quiet) {
      cat(paste0("Successfully read ", nrow(samples_dataframe), " rows of data from ", samples.file, " and ", objectives.file, "\n"))
    }

    #########################
    ## Merge the Two dataframes and print result
    #########################
    result <- bind_cols(objective_dataframe, samples_dataframe)
  } else {
    return_covariance <- FALSE
    result <- samples_dataframe
    if (!quiet) {
      cat(paste0("No objectives.file supplied. Successfully read ", nrow(samples_dataframe), " rows of data from ", samples.file, "\n"))
    }
  }
  result <- set.class(result, "casal2MCMC")
  if (!return_covariance) {
    return(result)
  } else {
    final_result <- list(Data = result, Covariance = covariance_matrix)
    return(final_result)
  }
}
